//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Wed Dec  6 15:24:27 GMT 2017
//
//
// Ports:
// Name                         I/O  size props
// RDY_multiply                   O     1 const
// result                         O    72 reg
// RDY_result                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// multiply_m1                    I    32
// multiply_m2                    I    40
// multiply_k                     I     6 reg
// EN_multiply                    I     1
// EN_result                      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMulti(CLK,
	       RST_N,

	       multiply_m1,
	       multiply_m2,
	       multiply_k,
	       EN_multiply,
	       RDY_multiply,

	       EN_result,
	       result,
	       RDY_result);
  input  CLK;
  input  RST_N;

  // action method multiply
  input  [31 : 0] multiply_m1;
  input  [39 : 0] multiply_m2;
  input  [5 : 0] multiply_k;
  input  EN_multiply;
  output RDY_multiply;

  // actionvalue method result
  input  EN_result;
  output [71 : 0] result;
  output RDY_result;

  // signals for module outputs
  wire [71 : 0] result;
  wire RDY_multiply, RDY_result;

  // register a
  reg [31 : 0] a;
  wire [31 : 0] a$D_IN;
  wire a$EN;

  // register available
  reg available;
  wire available$D_IN, available$EN;

  // register b
  reg [39 : 0] b;
  wire [39 : 0] b$D_IN;
  wire b$EN;

  // register cal
  reg cal;
  wire cal$D_IN, cal$EN;

  // register check
  reg check;
  wire check$D_IN, check$EN;

  // register finalans
  reg [71 : 0] finalans;
  wire [71 : 0] finalans$D_IN;
  wire finalans$EN;

  // register fl
  reg fl;
  wire fl$D_IN, fl$EN;

  // register flag
  reg flag;
  wire flag$D_IN, flag$EN;

  // register mcand
  reg [5 : 0] mcand;
  wire [5 : 0] mcand$D_IN;
  wire mcand$EN;

  // register mplr
  reg [5 : 0] mplr;
  wire [5 : 0] mplr$D_IN;
  wire mplr$EN;

  // register p1
  reg [5 : 0] p1;
  wire [5 : 0] p1$D_IN;
  wire p1$EN;

  // register p2
  reg [5 : 0] p2;
  wire [5 : 0] p2$D_IN;
  wire p2$EN;

  // register pos1
  reg [5 : 0] pos1;
  wire [5 : 0] pos1$D_IN;
  wire pos1$EN;

  // register pos2
  reg [5 : 0] pos2;
  wire [5 : 0] pos2$D_IN;
  wire pos2$EN;

  // register regk
  reg [5 : 0] regk;
  wire [5 : 0] regk$D_IN;
  wire regk$EN;

  // register sign
  reg sign;
  wire sign$D_IN, sign$EN;

  // register x
  reg [31 : 0] x;
  wire [31 : 0] x$D_IN;
  wire x$EN;

  // register y
  reg [39 : 0] y;
  wire [39 : 0] y$D_IN;
  wire y$EN;

  // ports of submodule ans
  wire [71 : 0] ans$D_IN, ans$D_OUT;
  wire ans$CLR, ans$DEQ, ans$EMPTY_N, ans$ENQ, ans$FULL_N;

  // remaining internal signals
  wire [71 : 0] x__h6114, x__h6190, x__h6191;
  wire [39 : 0] x__h6412,
		y_AND_INV_0xFFFFFFFFFE_SL_i1012_SRL_0__q4,
		y_AND_INV_0xFFFFFFFFFE_SL_pos2_SRL_i2935__q3;
  wire [31 : 0] x_AND_INV_0xFFFFFFFE_SL_i1012_BITS_4_TO_0_SRL_0__q2,
		x_AND_INV_0xFFFFFFFE_SL_pos1_BITS_4_TO_0_SRL_i_ETC__q1,
		x__h6310;
  wire [11 : 0] mcand_10_MUL_mplr_11___d212;
  wire [5 : 0] i1__h6012,
	       i2__h5688,
	       i2__h5935,
	       x__h5676,
	       x__h5714,
	       x__h5797,
	       x__h5923,
	       x__h5941,
	       x__h6001,
	       x__h6206,
	       x__h6208,
	       y__h6192,
	       y__h6209;
  wire pos1_82_ULT_regk_83___d184, pos2_96_ULT_regk_83___d197;

  // action method multiply
  assign RDY_multiply = 1'd1 ;

  // actionvalue method result
  assign result = ans$D_OUT ;
  assign RDY_result = ans$EMPTY_N ;

  // submodule ans
  FIFO2 #(.width(32'd72), .guarded(32'd1)) ans(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(ans$D_IN),
					       .ENQ(ans$ENQ),
					       .DEQ(ans$DEQ),
					       .CLR(ans$CLR),
					       .D_OUT(ans$D_OUT),
					       .FULL_N(ans$FULL_N),
					       .EMPTY_N(ans$EMPTY_N));

  // register a
  assign a$D_IN = multiply_m1[31] ? x__h6310 : multiply_m1 ;
  assign a$EN = EN_multiply ;

  // register available
  assign available$D_IN = 1'd1 ;
  assign available$EN = EN_multiply ;

  // register b
  assign b$D_IN = multiply_m2[39] ? x__h6412 : multiply_m2 ;
  assign b$EN = EN_multiply ;

  // register cal
  assign cal$D_IN = 1'd1 ;
  assign cal$EN = check ;

  // register check
  assign check$D_IN = 1'd1 ;
  assign check$EN = available ;

  // register finalans
  assign finalans$D_IN = 72'h0 ;
  assign finalans$EN = 1'b0 ;

  // register fl
  assign fl$D_IN = flag ;
  assign fl$EN = available ;

  // register flag
  assign flag$D_IN = multiply_m1[31] != multiply_m2[39] ;
  assign flag$EN = EN_multiply ;

  // register mcand
  assign mcand$D_IN = pos2_96_ULT_regk_83___d197 ? x__h6001 : x__h5923 ;
  assign mcand$EN = check ;

  // register mplr
  assign mplr$D_IN = pos1_82_ULT_regk_83___d184 ? x__h5797 : x__h5676 ;
  assign mplr$EN = check ;

  // register p1
  assign p1$D_IN = pos1_82_ULT_regk_83___d184 ? i1__h6012 : pos1 ;
  assign p1$EN = check ;

  // register p2
  assign p2$D_IN = pos2_96_ULT_regk_83___d197 ? i1__h6012 : pos2 ;
  assign p2$EN = check ;

  // register pos1
  assign pos1$D_IN =
	     a[31] ?
	       6'd31 :
	       (a[30] ?
		  6'd30 :
		  (a[29] ?
		     6'd29 :
		     (a[28] ?
			6'd28 :
			(a[27] ?
			   6'd27 :
			   (a[26] ?
			      6'd26 :
			      (a[25] ?
				 6'd25 :
				 (a[24] ?
				    6'd24 :
				    (a[23] ?
				       6'd23 :
				       (a[22] ?
					  6'd22 :
					  (a[21] ?
					     6'd21 :
					     (a[20] ?
						6'd20 :
						(a[19] ?
						   6'd19 :
						   (a[18] ?
						      6'd18 :
						      (a[17] ?
							 6'd17 :
							 (a[16] ?
							    6'd16 :
							    (a[15] ?
							       6'd15 :
							       (a[14] ?
								  6'd14 :
								  (a[13] ?
								     6'd13 :
								     (a[12] ?
									6'd12 :
									(a[11] ?
									   6'd11 :
									   (a[10] ?
									      6'd10 :
									      (a[9] ?
										 6'd9 :
										 (a[8] ?
										    6'd8 :
										    (a[7] ?
										       6'd7 :
										       6'd6)))))))))))))))))))))))) ;
  assign pos1$EN =
	     available &&
	     (a[31] || a[30] || a[29] || a[28] || a[27] || a[26] || a[25] ||
	      a[24] ||
	      a[23] ||
	      a[22] ||
	      a[21] ||
	      a[20] ||
	      a[19] ||
	      a[18] ||
	      a[17] ||
	      a[16] ||
	      a[15] ||
	      a[14] ||
	      a[13] ||
	      a[12] ||
	      a[11] ||
	      a[10] ||
	      a[9] ||
	      a[8] ||
	      a[7] ||
	      a[6]) ;

  // register pos2
  assign pos2$D_IN =
	     b[39] ?
	       6'd39 :
	       (b[38] ?
		  6'd38 :
		  (b[37] ?
		     6'd37 :
		     (b[36] ?
			6'd36 :
			(b[35] ?
			   6'd35 :
			   (b[34] ?
			      6'd34 :
			      (b[33] ?
				 6'd33 :
				 (b[32] ?
				    6'd32 :
				    (b[31] ?
				       6'd31 :
				       (b[30] ?
					  6'd30 :
					  (b[29] ?
					     6'd29 :
					     (b[28] ?
						6'd28 :
						(b[27] ?
						   6'd27 :
						   (b[26] ?
						      6'd26 :
						      (b[25] ?
							 6'd25 :
							 (b[24] ?
							    6'd24 :
							    (b[23] ?
							       6'd23 :
							       (b[22] ?
								  6'd22 :
								  (b[21] ?
								     6'd21 :
								     (b[20] ?
									6'd20 :
									(b[19] ?
									   6'd19 :
									   (b[18] ?
									      6'd18 :
									      (b[17] ?
										 6'd17 :
										 (b[16] ?
										    6'd16 :
										    (b[15] ?
										       6'd15 :
										       (b[14] ?
											  6'd14 :
											  (b[13] ?
											     6'd13 :
											     (b[12] ?
												6'd12 :
												(b[11] ?
												   6'd11 :
												   (b[10] ?
												      6'd10 :
												      (b[9] ?
													 6'd9 :
													 (b[8] ?
													    6'd8 :
													    (b[7] ?
													       6'd7 :
													       6'd6)))))))))))))))))))))))))))))))) ;
  assign pos2$EN =
	     available &&
	     (b[39] || b[38] || b[37] || b[36] || b[35] || b[34] || b[33] ||
	      b[32] ||
	      b[31] ||
	      b[30] ||
	      b[29] ||
	      b[28] ||
	      b[27] ||
	      b[26] ||
	      b[25] ||
	      b[24] ||
	      b[23] ||
	      b[22] ||
	      b[21] ||
	      b[20] ||
	      b[19] ||
	      b[18] ||
	      b[17] ||
	      b[16] ||
	      b[15] ||
	      b[14] ||
	      b[13] ||
	      b[12] ||
	      b[11] ||
	      b[10] ||
	      b[9] ||
	      b[8] ||
	      b[7] ||
	      b[6]) ;

  // register regk
  assign regk$D_IN = multiply_k ;
  assign regk$EN = EN_multiply ;

  // register sign
  assign sign$D_IN = fl ;
  assign sign$EN = check ;

  // register x
  assign x$D_IN = a ;
  assign x$EN = available ;

  // register y
  assign y$D_IN = b ;
  assign y$EN = available ;

  // submodule ans
  assign ans$D_IN = sign ? x__h6114 : x__h6190 ;
  assign ans$ENQ = ans$FULL_N && cal ;
  assign ans$DEQ = EN_result ;
  assign ans$CLR = 1'b0 ;

  // remaining internal signals
  assign i1__h6012 = regk - 6'd1 ;
  assign i2__h5688 = x__h5714 + 6'd1 ;
  assign i2__h5935 = x__h5941 + 6'd1 ;
  assign mcand_10_MUL_mplr_11___d212 = mcand * mplr ;
  assign pos1_82_ULT_regk_83___d184 = pos1 < regk ;
  assign pos2_96_ULT_regk_83___d197 = pos2 < regk ;
  assign x_AND_INV_0xFFFFFFFE_SL_i1012_BITS_4_TO_0_SRL_0__q2 =
	     (x & ~(32'hFFFFFFFE << i1__h6012[4:0])) >> 0 ;
  assign x_AND_INV_0xFFFFFFFE_SL_pos1_BITS_4_TO_0_SRL_i_ETC__q1 =
	     (x & ~(32'hFFFFFFFE << pos1[4:0])) >> i2__h5688[4:0] ;
  assign x__h5676 =
	     x_AND_INV_0xFFFFFFFE_SL_pos1_BITS_4_TO_0_SRL_i_ETC__q1[5:0] ;
  assign x__h5714 = pos1 - regk ;
  assign x__h5797 = x_AND_INV_0xFFFFFFFE_SL_i1012_BITS_4_TO_0_SRL_0__q2[5:0] ;
  assign x__h5923 = y_AND_INV_0xFFFFFFFFFE_SL_pos2_SRL_i2935__q3[5:0] ;
  assign x__h5941 = pos2 - regk ;
  assign x__h6001 = y_AND_INV_0xFFFFFFFFFE_SL_i1012_SRL_0__q4[5:0] ;
  assign x__h6114 = ~x__h6190 + 72'd1 ;
  assign x__h6190 = x__h6191 << y__h6192 ;
  assign x__h6191 = { 60'd0, mcand_10_MUL_mplr_11___d212 } ;
  assign x__h6206 = x__h6208 - y__h6209 ;
  assign x__h6208 = p1 + p2 ;
  assign x__h6310 = ~multiply_m1 + 32'd1 ;
  assign x__h6412 = ~multiply_m2 + 40'd1 ;
  assign y_AND_INV_0xFFFFFFFFFE_SL_i1012_SRL_0__q4 =
	     (y & ~(40'hFFFFFFFFFE << i1__h6012)) >> 0 ;
  assign y_AND_INV_0xFFFFFFFFFE_SL_pos2_SRL_i2935__q3 =
	     (y & ~(40'hFFFFFFFFFE << pos2)) >> i2__h5935 ;
  assign y__h6192 = x__h6206 + 6'd2 ;
  assign y__h6209 = { regk[4:0], 1'd0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 32'd0;
	available <= `BSV_ASSIGNMENT_DELAY 1'd0;
	b <= `BSV_ASSIGNMENT_DELAY 40'd0;
	cal <= `BSV_ASSIGNMENT_DELAY 1'd0;
	check <= `BSV_ASSIGNMENT_DELAY 1'd0;
	finalans <= `BSV_ASSIGNMENT_DELAY 72'd0;
	fl <= `BSV_ASSIGNMENT_DELAY 1'd0;
	flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	mcand <= `BSV_ASSIGNMENT_DELAY 6'd0;
	mplr <= `BSV_ASSIGNMENT_DELAY 6'd0;
	p1 <= `BSV_ASSIGNMENT_DELAY 6'd0;
	p2 <= `BSV_ASSIGNMENT_DELAY 6'd0;
	pos1 <= `BSV_ASSIGNMENT_DELAY 6'd0;
	pos2 <= `BSV_ASSIGNMENT_DELAY 6'd0;
	regk <= `BSV_ASSIGNMENT_DELAY 6'd0;
	sign <= `BSV_ASSIGNMENT_DELAY 1'd0;
	x <= `BSV_ASSIGNMENT_DELAY 32'd0;
	y <= `BSV_ASSIGNMENT_DELAY 40'd0;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (available$EN) available <= `BSV_ASSIGNMENT_DELAY available$D_IN;
	if (b$EN) b <= `BSV_ASSIGNMENT_DELAY b$D_IN;
	if (cal$EN) cal <= `BSV_ASSIGNMENT_DELAY cal$D_IN;
	if (check$EN) check <= `BSV_ASSIGNMENT_DELAY check$D_IN;
	if (finalans$EN) finalans <= `BSV_ASSIGNMENT_DELAY finalans$D_IN;
	if (fl$EN) fl <= `BSV_ASSIGNMENT_DELAY fl$D_IN;
	if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (mcand$EN) mcand <= `BSV_ASSIGNMENT_DELAY mcand$D_IN;
	if (mplr$EN) mplr <= `BSV_ASSIGNMENT_DELAY mplr$D_IN;
	if (p1$EN) p1 <= `BSV_ASSIGNMENT_DELAY p1$D_IN;
	if (p2$EN) p2 <= `BSV_ASSIGNMENT_DELAY p2$D_IN;
	if (pos1$EN) pos1 <= `BSV_ASSIGNMENT_DELAY pos1$D_IN;
	if (pos2$EN) pos2 <= `BSV_ASSIGNMENT_DELAY pos2$D_IN;
	if (regk$EN) regk <= `BSV_ASSIGNMENT_DELAY regk$D_IN;
	if (sign$EN) sign <= `BSV_ASSIGNMENT_DELAY sign$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 32'hAAAAAAAA;
    available = 1'h0;
    b = 40'hAAAAAAAAAA;
    cal = 1'h0;
    check = 1'h0;
    finalans = 72'hAAAAAAAAAAAAAAAAAA;
    fl = 1'h0;
    flag = 1'h0;
    mcand = 6'h2A;
    mplr = 6'h2A;
    p1 = 6'h2A;
    p2 = 6'h2A;
    pos1 = 6'h2A;
    pos2 = 6'h2A;
    regk = 6'h2A;
    sign = 1'h0;
    x = 32'hAAAAAAAA;
    y = 40'hAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMulti

